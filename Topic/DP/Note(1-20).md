# 1 - Range Sum Query 2D
## a) range sum 的 trick： 
s(i,j) 为 从0,0 到i, j 的累加和  
sum（x1,y1,x2,y2）= s（x2,y2）- s(x2,y1-1) - s(x1-1,y2)+s(x1-1,y1-1)  
## b) 经典的2D grid 规划  
下标从小到大这样遍历过去就行了，对于i,j时，任何下标小于i-1，i-2... 和 j-1，j-2,j-3...都可以利用
```
for(int i=0;...){
    for(int j;...){

    }
}
```

# 2 - Longest Palindromic Substring
## a) 哪里看出用DP
一个回文子串，可以通过两边拓展，成为一个更长的回文子串。  
这种利用子问题，逐步生长的感觉，就是状态转移的感觉。  
## b) 转移的未必是值  
这里的状态S（i,j）我假设的是，i，j之间的序列是否为回文，是个布尔标记值。  
## c) **核心是如何利用重复子问题！**
这题DP不典型，但是只要从如何运用已经侦测到的子回文，即如何运用子问题，那么，一切都是很自然的事情。  

# 3 - Triangle 
## a） 哪里看出用DP
这题倒不是一下子看出，有很明显的重叠子问题。  
而是这里有很强的递归性，所有解都是自上而下，有方向性的扩展，多加一层的状态转移也很明显。  
## b） 层级化的经典模型  
其实可以把这个标记为一个经典模型： 层级化，下一层利用上一层的局部结论。

# 4 - Coin Change
## a) 从哪里看出用DP
这题简直不要太像背包问题。  

## b) 掌握经典模型的好处  
经典模型就像short cut， 是对本质的一次抽象和封装。  
很多时候，一旦联系到经典模型，我们就直接从模型出发，而不用从头观察，这就是极大的好处！！

# 5 - Shopping Offers
## a) 又是一个背包问题  
不过这题特殊的是，我们未必要采用动态规划来消除冗余。因为动态规划写起来不是很好写，这的维度和状态转移都很复杂。相反，我们可以通过“
## b）top-down ，通过顺序来消除冗余 
这题直接用背包模式的话，维度和item的数量成正比。写起来困难。  
但是用DFS的话，要用得有技巧。同样可以减小递归中的重复计算。  
**有组织的DFS**  
 - 减少同配方，多顺序组合的遍历  
对offer 编号， 顺序采用。传个index 表示， index之前的offer 都考虑过了。  这样可以减少offer配方一样，但是遍历顺序不一样的组合。  
 - 最后再考虑“单买”   
 其实就是就是给“单买”也编号，放在最后执行。同样的是减少同配方多组合的情况
 
 ## c） DP方法
 b）的方法，其实也可用转化为bottom-up 的方法。 

 S（k，V）为状态，k表示只考虑啊前k个offer的方法，v表示剩余要买的item，值为已经付了的钱。  
 那么： S（k，V） = min{S（k-1, V1）+ offer_price*1,..... }  
 我们要求的答案，就是S(k+1,V)其中v为全0，k+1的offer是通通单买。  
 
 # 6 - Counting Bits
 
 这题有O（n）的解法，我一开也没看出是有DP。  
 ## a) 那里可以利用的子问题？  
 如果我们知道了101010 有3个，那么1101010（即前面加一个1），一定是有4个，而这之间的距离，是恒定的。   
 ## b) 为什么我也尝试寻找重复利用的，但是失败了？  
 因为我找n的时候，把目光局限于n-1,因此自然地想到维护number来模拟进位. 而在DP中，目光应该放在n之前的所有子问题，即从n-1，到...3,2,1,0.
    
# 7 - Domino and Tromino Tiling
## a) 分类树模型
我要铺满，如何选择瓦片，需要进行分类讨论，这就是从一个节点岔开的地方。
## b）为何用DP  
这里的状态，就是规模(n)。因为铺瓦片过程中是**规模扩张的一个过程**。
## c) *非DP注意点  
分类树基本是指数扩张，这里很容易溢出。 题目要我们结果用一个大数取模表示。 这里需要了解的，如何从模中计算出模，而不是从原数中计算出模。

# 8 - New 21 Game（未完待续）
## a） 为何用DP ： 分类树->存在进度 
存在进度条，这种进度条模型，可以通过子进度条来进行转移。  
这里的进度，在于不断摇色子，而第7题多米诺tiling的进度，在于不断的摆拼图。而状态也很明显，就是进度、里程碑。

## b） 难转移？难表示？：看一下是否要加一个限定条件。
概率很难表示，因为我P（n）表示，最终只投到n的概率。P（i）和P（j）比较难转移。很难保证最后概率加起来等于1.  
  
  这是因为，我忽略了另一个限定条件K。 因为如果表示P（n）为最终概率，那么子问题也要是最终概率，那么这个限定最终概率的K， 也需要动态扩张来适配子问题。于是，也要加入状态。  

因此P（n,k）表示K取k时，最终为n的概率。 而n= k , k+1 .... k+W-1 

## c)再谈分类树：如何检查是否漏解。  
这种模型的DP，类型往往不是S（n）=max{....} 而是S(n)= kS(n-1)..+.. 是类似于斐波那契。   
因此只需要把所有的直接来源给补齐，所有的间接来源都不要算。 用树的话来说，就是只算父节点，祖父节点什么的以上都不要算。

## d） DP的艺术：横看成岭侧成峰  
这题我的解法没有错，但是是O(k*n). 但其实换一种状态，可以做到O（k）。   
概率之和未必为1？  
因为，我

# 9 - Strange Printer（待续）
## a) why DP?
序列的天生递归性+print的过程又是一个分类树
## b) 难在哪里？
转移关系比较难搞定，缺条件？加状态纬度？可是已经二维了啊，肯定有更加简单的放啊

# 10 - Partition Equal Subset Sum
## a) why dp
和01背包问题很像：
## b) 没有最优值
这里么似乎没有所谓的“最优值”。也就是遍历的那个Max/Min是不存在的。所以他要吧所有可能的解给保存起来。 但是这样的复杂度，可就是O(2^n)了。
## c） 优化1:复杂度，是2^n ?
并不是，d[i][n] 虽然每次第i 个加或不加，都会造成一次*=2的分裂，但是每一轮的分裂，都是有重复的结果。   
**因此，只要用hash的方式存n，就能简单地消除重复**。
## d）优化2:空间优化 
这里每一轮都开一个hash很浪费，实际上，这是可以公用的一个hash的。因为每次跟新，上一轮的原有值都会保留的。

# 11 -  Longest Turbulent Subarray
## a) why dp ：重叠子问题-双端序列模型
很明显的，暴力搜索出现重叠子问题。  
## b） 有比DP更快的吗？
这题是有的，因为他根本不需要遍历in the first place!

