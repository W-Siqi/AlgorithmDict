# 1 - Range Sum Query 2D
## a) range sum 的 trick： 
s(i,j) 为 从0,0 到i, j 的累加和  
sum（x1,y1,x2,y2）= s（x2,y2）- s(x2,y1-1) - s(x1-1,y2)+s(x1-1,y1-1)  
## b) 经典的2D grid 规划  
下标从小到大这样遍历过去就行了，对于i,j时，任何下标小于i-1，i-2... 和 j-1，j-2,j-3...都可以利用
```
for(int i=0;...){
    for(int j;...){

    }
}
```

# 2 - Longest Palindromic Substring
## a) 哪里看出用DP
一个回文子串，可以通过两边拓展，成为一个更长的回文子串。  
这种利用子问题，逐步生长的感觉，就是状态转移的感觉。  
## b) 转移的未必是值  
这里的状态S（i,j）我假设的是，i，j之间的序列是否为回文，是个布尔标记值。  
## c) **核心是如何利用重复子问题！**
这题DP不典型，但是只要从如何运用已经侦测到的子回文，即如何运用子问题，那么，一切都是很自然的事情。  

# 3 - Triangle 
## a） 哪里看出用DP
这题倒不是一下子看出，有很明显的重叠子问题。  
而是这里有很强的递归性，所有解都是自上而下，有方向性的扩展，多加一层的状态转移也很明显。  
## b） 层级化的经典模型  
其实可以把这个标记为一个经典模型： 层级化，下一层利用上一层的局部结论。

# 4 - Coin Change
## a) 从哪里看出用DP
这题简直不要太像背包问题。  

## b) 掌握经典模型的好处  
经典模型就像short cut， 是对本质的一次抽象和封装。  
很多时候，一旦联系到经典模型，我们就直接从模型出发，而不用从头观察，这就是极大的好处！！

# 5 - Shopping Offers
## a) 又是一个背包问题  
不过这题特殊的是，我们未必要采用动态规划来消除冗余。因为动态规划写起来不是很好写，这的维度和状态转移都很复杂。相反，我们可以通过“
## b）top-down ，通过顺序来消除冗余 
这题直接用背包模式的话，维度和item的数量成正比。写起来困难。  
但是用DFS的话，要用得有技巧。同样可以减小递归中的重复计算。  
**有组织的DFS**  
 - 减少同配方，多顺序组合的遍历  
对offer 编号， 顺序采用。传个index 表示， index之前的offer 都考虑过了。  这样可以减少offer配方一样，但是遍历顺序不一样的组合。  
 - 最后再考虑“单买”   
 其实就是就是给“单买”也编号，放在最后执行。同样的是减少同配方多组合的情况
 
 ## c） DP方法
 b）的方法，其实也可用转化为bottom-up 的方法。 

 S（k，V）为状态，k表示只考虑啊前k个offer的方法，v表示剩余要买的item，值为已经付了的钱。  
 那么： S（k，V） = min{S（k-1, V1）+ offer_price*1,..... }  
 我们要求的答案，就是S(k+1,V)其中v为全0，k+1的offer是通通单买。  
 