# 1 - Range Sum Query 2D
## a) range sum 的 trick： 
s(i,j) 为 从0,0 到i, j 的累加和  
sum（x1,y1,x2,y2）= s（x2,y2）- s(x2,y1-1) - s(x1-1,y2)+s(x1-1,y1-1)  
## b) 经典的2D grid 规划  
下标从小到大这样遍历过去就行了，对于i,j时，任何下标小于i-1，i-2... 和 j-1，j-2,j-3...都可以利用
```
for(int i=0;...){
    for(int j;...){

    }
}
```

# 2 - Longest Palindromic Substring
## a) 哪里看出用DP
一个回文子串，可以通过两边拓展，成为一个更长的回文子串。  
这种利用子问题，逐步生长的感觉，就是状态转移的感觉。  
## b) 转移的未必是值  
这里的状态S（i,j）我假设的是，i，j之间的序列是否为回文，是个布尔标记值。  
## c) **核心是如何利用重复子问题！**
这题DP不典型，但是只要从如何运用已经侦测到的子回文，即如何运用子问题，那么，一切都是很自然的事情。  

# 3 - Triangle 
## a） 哪里看出用DP
这题倒不是一下子看出，有很明显的重叠子问题。  
而是这里有很强的递归性，所有解都是自上而下，有方向性的扩展，多加一层的状态转移也很明显。  
## b） 层级化的经典模型  
其实可以把这个标记为一个经典模型： 层级化，下一层利用上一层的局部结论。

# 4 - Coin Change
## a) 从哪里看出用DP
这题简直不要太像背包问题。  

## b) 掌握经典模型的好处  
经典模型就像short cut， 是对本质的一次抽象和封装。  
很多时候，一旦联系到经典模型，我们就直接从模型出发，而不用从头观察，这就是极大的好处！！

# 5 - Shopping Offers
## a) 又是一个背包问题  
不过这题特殊的是，我们未必要采用动态规划来消除冗余。因为动态规划写起来不是很好写，这的维度和状态转移都很复杂。相反，我们可以通过“
## b）top-down ，通过顺序来消除冗余 
这题直接用背包模式的话，维度和item的数量成正比。写起来困难。  
但是用DFS的话，要用得有技巧。同样可以减小递归中的重复计算。  
**有组织的DFS**  
 - 减少同配方，多顺序组合的遍历  
对offer 编号， 顺序采用。传个index 表示， index之前的offer 都考虑过了。  这样可以减少offer配方一样，但是遍历顺序不一样的组合。  
 - 最后再考虑“单买”   
 其实就是就是给“单买”也编号，放在最后执行。同样的是减少同配方多组合的情况
 
 ## c） DP方法
 b）的方法，其实也可用转化为bottom-up 的方法。 

 S（k，V）为状态，k表示只考虑啊前k个offer的方法，v表示剩余要买的item，值为已经付了的钱。  
 那么： S（k，V） = min{S（k-1, V1）+ offer_price*1,..... }  
 我们要求的答案，就是S(k+1,V)其中v为全0，k+1的offer是通通单买。  
 
 # 6 - Counting Bits
 
 这题有O（n）的解法，我一开也没看出是有DP。  
 ## a) 那里可以利用的子问题？  
 如果我们知道了101010 有3个，那么1101010（即前面加一个1），一定是有4个，而这之间的距离，是恒定的。   
 ## b) 为什么我也尝试寻找重复利用的，但是失败了？  
 因为我找n的时候，把目光局限于n-1,因此自然地想到维护number来模拟进位. 而在DP中，目光应该放在n之前的所有子问题，即从n-1，到...3,2,1,0.
    
# 7 - Domino and Tromino Tiling
## a) 分类树模型
我要铺满，如何选择瓦片，需要进行分类讨论，这就是从一个节点岔开的地方。
## b）为何用DP  
这里的状态，就是规模(n)。因为铺瓦片过程中是**规模扩张的一个过程**。
## c) *非DP注意点  
分类树基本是指数扩张，这里很容易溢出。 题目要我们结果用一个大数取模表示。 这里需要了解的，如何从模中计算出模，而不是从原数中计算出模。

# 8 - New 21 Game（未完待续）
## a） 为何用DP  
存在进度条，这种进度条模型，可以通过子进度条来进行转移。  
这里的进度，在于不断摇色子，而第7题多米诺tiling的进度，在于不断的摆拼图。而状态也很明显，就是进度、里程碑。