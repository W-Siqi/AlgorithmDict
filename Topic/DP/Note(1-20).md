# 1 - Range Sum Query 2D
## a) range sum 的 trick： 
s(i,j) 为 从0,0 到i, j 的累加和  
sum（x1,y1,x2,y2）= s（x2,y2）- s(x2,y1-1) - s(x1-1,y2)+s(x1-1,y1-1)  
## b) 经典的2D grid 规划  
下标从小到大这样遍历过去就行了，对于i,j时，任何下标小于i-1，i-2... 和 j-1，j-2,j-3...都可以利用
```
for(int i=0;...){
    for(int j;...){

    }
}
```

# 2 - Longest Palindromic Substring
## a) 哪里看出用DP
一个回文子串，可以通过两边拓展，成为一个更长的回文子串。  
这种利用子问题，逐步生长的感觉，就是状态转移的感觉。  
## b) 转移的未必是值  
这里的状态S（i,j）我假设的是，i，j之间的序列是否为回文，是个布尔标记值。  
## c) **核心是如何利用重复子问题！**
这题DP不典型，但是只要从如何运用已经侦测到的子回文，即如何运用子问题，那么，一切都是很自然的事情。  

# 3 - Triangle 
## a） 哪里看出用DP
这题倒不是一下子看出，有很明显的重叠子问题。  
而是这里有很强的递归性，所有解都是自上而下，有方向性的扩展，多加一层的状态转移也很明显。  
## b） 层级化的经典模型  
其实可以把这个标记为一个经典模型： 层级化，下一层利用上一层的局部结论。

# 4 - Coin Change
## a) 从哪里看出用DP
这题简直不要太像背包问题。  

## b) 掌握经典模型的好处  
经典模型就像short cut， 是对本质的一次抽象和封装。  
很多时候，一旦联系到经典模型，我们就直接从模型出发，而不用从头观察，这就是极大的好处！！