# 1 - DP的实质
### **是一种优化策略：通过只计算一次重叠子问题，消去递归中冗余计算。**

## DAG 表述
几乎所有的DP情形都可以描述为一个有向图（DAG）：    

 - 每个节点都是代表一个状态，每条边链接了两个状态，同时又各自的cost。 寻找最优解的实质，不过寻找从初始节点到目标节点的最短路。    

 - 而动态规划的过程在于，要找到达某一点的最短路，只要分别求出其前驱的最短路，再取最优值即可。**因为这一点只有可能从前驱得来**。  
  - 所以DP为什么work？ 因为 1） 状态可转移，我们可以直接利用该状态的值，而不必要知道这个状态是怎么来的（是经过了哪些节点而来）2）保证前驱最优，以及前驱完备，那么就一定能推出最优的下一步。  这两个条件一保证，那么结果就是妥妥的最优解了，不用担心漏情况之类的东西了。
# 2 - DP的关键点
## 2.1 - 什么时候用DP?
- 自然递归性质（前提性）  
问题的核心逻辑结构是**序列、集合、树、图、矩阵** 这样天生代递归性的。如果没有递归，那么子问题和母问题之间没法转移。  

- 搜索中存在冗余 （必要性）
递归性质的逻辑结构在问题中很常见，但并不是所有都需要动态规划。   
有的题可以通过设计规则，或贪心之类的避免了暴力搜索。**只有当走投无路，走上搜索这条贼船，而且搜索中存在重复计算** 才需要考虑，能否使用动态规划。

## 2.2 - 状态
状态的定义十分艺术，不管怎么样，你定义的状态应该和是**能很好的表述子问题的最优解** ， 从而方便子问题的重复利用（即状态的转移）
 -  状态的维度   
 状态不一定是单维度的，很多重要的信息，以及限定条件，我们需要**作为状态的一个维度来进行跟踪**。

## 2.3 - 顺序
更新状态的顺序十分重要，一个原则就是：**在更新一个状态是，保证它的所有前驱已经更新完毕。**  
（当然，有的写法是按元素更新，而不是按状态更新，这里讨论的是按状态更新）
 

# 3 - 经典例题
## 3.1 - 背包-无序集合模型
### a.无限背包  

### b.01背包

## 3.2 - 字符串-序列模型
### a.最大递增子序列

### b.编辑距离

## 3.3 - 最短路-限制与多维度
 - Dijstra 是动态规划吗？

### a.带限定的最短路

### b.全最短路径

### c.销售员问题