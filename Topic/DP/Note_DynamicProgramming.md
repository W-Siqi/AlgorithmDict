# 1 - DP的实质
### **是一种优化策略：通过只计算一次重叠子问题，消去递归中冗余计算。**

## DAG 表述
几乎所有的DP情形都可以描述为一个有向图（DAG）：    

 - 每个节点都是代表一个状态，每条边链接了两个状态，同时又各自的cost。 寻找最优解的实质，不过寻找从初始节点到目标节点的最短路。    

 - 而动态规划的过程在于，要找到达某一点的最短路，只要分别求出其前驱的最短路，再取最优值即可。**因为这一点只有可能从前驱得来**。  
  - 所以DP为什么work？ 因为   
  1） 状态可转移，我们可以直接利用该状态的值，而不必要知道这个状态是怎么来的（是经过了哪些节点而来）  
  2）保证前驱最优：正确的计算顺序很重要   
  3）保证前驱完备：不要漏掉可能的前驱最优解。  
  这些条件一保证，那么结果就是妥妥的最优解了，不用担心漏情况之类的东西了。
# 2 - DP的关键点
## 2.1 - 什么时候用DP?
- 自然递归性质（前提性）  
问题的核心逻辑结构是**序列、集合、树、图、矩阵** 这样天生代递归性的。如果没有递归，那么子问题和母问题之间没法转移。  

- 搜索中存在冗余 （必要性）  
递归性质的逻辑结构在问题中很常见，但并不是所有都需要动态规划。   
有的题可以通过设计规则，或贪心之类的避免了暴力搜索。**只有当走投无路，走上搜索这条贼船，而且搜索中存在重复计算** 才需要考虑，能否使用动态规划。

## 2.2 - 状态
状态的定义十分艺术，不管怎么样，你定义的状态应该和是**能很好的表述子问题的最优解** ， 从而方便子问题的重复利用（即状态的转移）
 -  状态的维度   
 状态不一定是单维度的，很多重要的信息，以及限定条件，我们需要**作为状态的一个维度来进行跟踪**。

## 2.3 - 顺序
更新状态的顺序十分重要，一个原则就是：**在更新一个状态是，保证它的所有前驱已经更新完毕。**  
（当然，有的写法是按元素更新，而不是按状态更新，这里讨论的是按状态更新）
 

# 3 - 经典例题
## 3.1 - 背包-无序集合模型
## a.无限背包  
 - 状态定义：  
d（w）表示重量为w时的最优价值。 很直接，因为重量是这道题唯一的一个**限定条件**。  
 - 状态转移  
d（w1）到d（w2）之间的桥梁也很明确，就是添加了物体。因此，所有类型的重量就代表了完备的前驱的集合。 
 - 顺序：   
w小的是w大的前驱，因此知道从0到max算过去就可以保证前驱最优。 
## b.01背包
分析：相比于无限背包，01背包又多了个限定条件。面对限定条件我们怎么办？ 当然是让状态添加一个维度来跟踪。   
 - 集合状态：编号法
我们比无限背包多了一个维度d(w,s)，w还是w，s表示是只考虑前s个物体的情况。  
这个状态和w不太一样，实际上，对于无序的集合，我们可以对其元素进行编号，然后再一步步扩张。
 - 前驱的完备性
我们把注意力放在s这个维度上，从s到s+1，代表多考虑一个。因此只有两种情况，放或不放。
 - 二维状态的顺序：
这里的前驱后驱还是很明显的，w和s都是按数值大小的。两层for就可以保证。

## 3.2 -序列-序列模型
序列本身就是一种递归模型，往前或往后加一个元素，还是序列。  
### a.最大递增子序列
 - 状态的定义S（i）：  
  这道题说明了状态的定义，**未必要和规模挂钩，而是与关键位置挂钩**。S（i）如果表示，到第i个结尾的规模，那么状态之间的关联性就没了，不方便转移 。  
  这里元素的拼接，光知道规模无法推断，要比较当前递增序列的末尾元素的大小。所以，**如果i表示成规模，那么需要额外加维度来跟踪**。也就是S(i,j)表示到第i个规模，第j个元素为结尾的。  
  这里因为“规模”在状态转移基本没提供什么额外信息，因此i表示以第i个结尾的，不但暗示进程，还提供了信息。
### b.编辑距离
 - 状态的定义S（i，j）  
 这里是有两个序列，那么他的规模自然是要有两个维度，分别表示两个序列的规模。
 - 前驱的完备性  
 这里需要考虑的，就是DAG中，哪些状态有链接。少算一个都是漏解。这里S（i，j）只能被S（i，j+1）， S（i+1,j）和S（j+1，i）重复利用。**这其实就是二维的状态的一种i++**。

### c.矩阵乘法
 - 树结构  
 这题虽然看上去是序列模型，但其实加括号层级这件事，是一个树结构，也就是子结构是一颗子树。
 - 发现重复计算  
 这题如果去暴力枚举的话，你会发现有很多重复的结构。比如第2到第7个字母的某一个层级结构被枚举了很多次。而这就是活生生的重叠子问题。  
 - 状态的定义S（i，j）  
 和最大递增子序列不同的是，这里的规模，是两端截取的，而不是一段截取的。这主要是子问题的利用结构 和 扩展结构的不同，这个只可会意，不可言传hhh。

## 3.3 - 最短路-限制与多维度
 - Dijstra 是动态规划吗？

### a.带限定的最短路

### b.全最短路径

### c.销售员问题