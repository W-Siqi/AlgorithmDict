# 5 - ContainerWithMostWater
KEY：两端遍历，剪支
## 5.1 - C++max/min
包含在c++标准库中头文件<algorithm>中，在头文件<windows.h>中定义了min,max的宏，
若在包含<algorithm>的同时包含<windows.h>会导致函数无法使用   

example:  

    a=max(a,val);  
    b=min(b.val);

## 5.2 - 剪枝
我R10的那个版本是暴力遍历，但是对于这种求max，min的，如果在一次遍历中可以估算预期最大值，就可以剪枝。  
比如当前高为h，就算它宽拉满也比不过现在的max，那么这一波就直接continue了  
于是就是有了R20版本，速度快了3倍 ！

## 5.3 最优解
这里还有O（n）的方法，但是我还法子证明他为什么work，先留着


# 6-Group Anagrams
这里其实就是一个如何高效判定两个字符串是否为anagram罢了。   
我一开始是层级化，先判长短，再判“校验和”，最后再排序。可惜，直接超时。而超时的排序是我自己随手写的.. 其实换成STL的sort()，连层级化都不用，直接暴力排序即可。  
## **hash code：**
我自己当时想的就是用一个严谨的key：a-z 数字累加，校验和。 这肯定不是唯一，所以只是作为粗判来优化。  
我看到有人用素数累乘，这倒是唯一的（因为分解质因数，就是素数自己）。但是，这个缺点是，如果字符串太长了会溢出。
## **使用sort**：
在紧密循环中的排序，不要自己胡乱写O(N2)的， 直接用STL。这种时间会差很多。
## **使用map：**
我R05和R84的区别，就是在组成group的方式，其他排序都是用sort的。  
我自己是用O（n2）的复杂度，而这种情况，可以用map来，因为map的查找效率是lgn，这样就变成O（nLgn）快了好多，而且容易写。
## 写法 for（auto c:str）
这样不容易出现下标错误，而且写起来方便。  
**但是**： 好像速度要慢一点？

# 7-Divide Two Int
KEY: 位移操作

## 关于位移操作
  左移  
  a=a<<1 就是左移1位，等于乘以2.  
  但是注意：注意符号位，最好转成正数再移，同时就算是正数，移爆掉了，也会把最高位顶成1.这样会就不对了。
## 注意int 的范围
范围是【-2^31,2^31-1】,所INX_MIN/(-1) 的时候会直接溢出。  
这里有两种解决方式：  
   1-用long int 来运算，最后再截取 （**对付数值溢出很管用的一个方法**）   
    2-直接if()把特例框出去，不要觉得丢脸，这比统一逻辑操作要方便多了**有时候特例能难囊括进来共用代码的时候，就直接if出去，省事儿又效率**
## 邪道解法
这题可以直接用数学公式钻空子...  
log（a/b）=log(a)-log(b)  
不过我觉得这不是出题者本意吧hhh

# Longest Substring Without Reapting
## KEY：字符串
这道题目思路上是对的，我一看就是有种字符串比配的感觉：即使是失败了，没有必要全部丢弃，而是有一个排除区间，从排除区间开始，这样就是O（n）的时间复杂度了    
（我写的R50是为了好写一点，实际上改一下也差不多是R99了）
## **使用hash：**
两个版本，R05是用map，R50是用hash  
由于map的频繁查找和初始化，导致速度比hash慢了50倍！！   
另外，对于字母的，可以手动用vector<int> hash[128], 用ASCII码直接hash  

# 9-Search In Rotated Array
这题没什么，应该是简单题。
## 二分查找标准写法
之前是弄递归的函数，而且还搞if特例，太麻烦  
```
  while(l<=r){
    auto mid=(l+r)/2;
            auto val=nums[mid];
            if(val==tar){return mid;}
            else if(val>tar){r=mid-1;}
            else {l=mid+1;}
    }
    return -1;
```

# 10-Multiply Strings
大数相乘吗，最直白的，就是模拟计算器嘛。  
但是直接这么做，是R10...，至于优化的话，下面有
## 优化-批处理 
是可以的，可以每次分好多个单位来，比如一次取10位。  
因为每次取1位的话，时间都花在读取数组上面去了。
## 优化-延迟进位
我是每次加一个数之后就开始了进位的操作，  
然而，可以不这么做，可以等全部加完了，再统一进位，这样只需要进位一次。  
速度从76ms 到了 8ms

# 11-Sum Root To Leaf Numbers
我觉得不配median难度，这道就是简单的树递归，没啥花样。 就是传递数字的时候，父节点*10+子节点=新数字。

## 12-Number of iland
找孤岛了，核心是递归连通块没错。  
但是结束之后再从头遍历找，未免有点O（n^2）？？  
## 可以优化的，到时候再说。

# 13-LRU Cache
O(1)的访问速度，我能想到的只有hash了（STL里面就是 unordered_map）
## 如何表示未赋值？ INIFITY？
这里我一开始使用vector放key的，这样缺省值就很麻烦，因为key是任意值。  
目前的，要么用bool musk[]，要么（在这个情形下） 直接用list  
## 记录LRU
目前的用list排序，reactive的话再放到head就好，永远保证head是要清除的

# ZigZag 
## KEY:归纳/数据结构
这题，其实观察一下，就会发现他的下标和row的关系是有固定周期的。    

要么直接根据周期，直接输出。  
要么用数据结构来中转一下（rt比较高，但是好写）。 这里最笨的就是用grid来存，当然，我是用vector<vector<char>> 稍微好一点，至少不超时。