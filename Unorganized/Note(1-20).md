# 5 - ContainerWithMostWater
KEY：两端遍历，剪支
## 5.1 - C++max/min
包含在c++标准库中头文件<algorithm>中，在头文件<windows.h>中定义了min,max的宏，
若在包含<algorithm>的同时包含<windows.h>会导致函数无法使用   

example:  

    a=max(a,val);  
    b=min(b.val);

## 5.2 - 剪枝
我R10的那个版本是暴力遍历，但是对于这种求max，min的，如果在一次遍历中可以估算预期最大值，就可以剪枝。  
比如当前高为h，就算它宽拉满也比不过现在的max，那么这一波就直接continue了  
于是就是有了R20版本，速度快了3倍 ！

## 5.3 最优解
这里还有O（n）的方法，但是我还法子证明他为什么work，先留着


# 6-Group Anagrams
这里其实就是一个如何高效判定两个字符串是否为anagram罢了。   
我一开始是层级化，先判长短，再判“校验和”，最后再排序。可惜，直接超时。而超时的排序是我自己随手写的.. 其实换成STL的sort()，连层级化都不用，直接暴力排序即可。  
## **hash code：**
我自己当时想的就是用一个严谨的key：a-z 数字累加，校验和。 这肯定不是唯一，所以只是作为粗判来优化。  
我看到有人用素数累乘，这倒是唯一的（因为分解质因数，就是素数自己）。但是，这个缺点是，如果字符串太长了会溢出。
## **使用sort**：
在紧密循环中的排序，不要自己胡乱写O(N2)的， 直接用STL。这种时间会差很多。
## **使用map：**
我R05和R84的区别，就是在组成group的方式，其他排序都是用sort的。  
我自己是用O（n2）的复杂度，而这种情况，可以用map来，因为map的查找效率是lgn，这样就变成O（nLgn）快了好多，而且容易写。
# 7-Divide Two Int
KEY: 位移操作

倒着减能减吗？
## 关于位移操作
  左移  
  a=a<<1 就是左移1位，等于乘以2.  
  但是注意：注意符号位，最好转成正数再移，同时就算是正数，移爆掉了，也会把最高位顶成1.这样会就不对了。
