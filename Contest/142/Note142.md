# 1 - Statistics from a Large Sample
## Key：简单题
null
## Failures：
标志变量忘记更新的bug
# 2 - Car Pooling
## Key：打表
### 思路1：直接打表  
我直接可以把每一站，有多少人都给弄出来，然后直接遍历一下不就得了？
## Failures:
null
# 3 - FindInMountainArray
## Key:观察归纳
分析：  
限制一百次访问，就是不让遍历咯  

### 思路1：  

这道题我看到的第一反应，就是有点“二分法”的神韵： 在规则和趋势可预测的情况下，搜寻目标。  
所以当时我的出发点就是截取范围，观察数值大小和范围之间的关系，啪：灵光一闪出来的。  
这个算法改进后可以这样：  
    -取中间2个数，如果是递增，那么抛弃左边的全部（峰顶不可能在左边）  
    -如果是递减，则抛弃右边的全部  
    -如果是中间最大，那么直接中奖，这就是峰顶  
    -如果只剩四五个元素，直接遍历  

### 思路2：
找到峰顶，就是找到最大的数。  
我们还是用二分法去猜，根据趋势（上升or下降）再去确定下一步的范围。比如发现是上升，那么继续向前二分，如果是下降，就往后二分。  
有趣的是，虽然这个和思路1的出发点不同，但是算法过程表现是完全一样的。
## Failures
null
# 4 - NAME4
## Key:
null
## Failures:
null
# Lession
## C++ 
### 类型转换 
### 传引用
## Vector的{}构造
新的C++标准应该是支持这样的（可能有的编译器不支持）
    vector<double> result{min,max,mean,median,mode};
但是不论如何，这样是肯定OK的

## 题目1-duplicate or not？
这道题上传了两个版本，一个是R99，一个是R84  
区别在于，求中位数的时候，如果一开始分支，是性能最优的，但是这样写代码会变长。  
我们可以抽出公共的代码，他们只是取数据的下标不同罢了，由于一些空白补全计算的机制，会时间长一点，但是这样明显不会超时呀！！
## 题目2-效率激进 
我看了下dalao的代码，十分简短。我拖拖拉拉写了