# 1-Distribute Candies To People
## KEY: 数学/模拟
直接模拟，试十分简单的，几行代码，一两分钟就能做完的。    

但是，为了更快的Runtime，可以直接推归纳出来的数学公式  
不过，根据数据范围，这题不卡Runtime，那么还是直接模拟比较好（为了效率的情况下）。

# 2-Path in ZigZag Binary Tree
## KEY:二叉树基础
### 主要是记住几个定律：  
1-在根节点为1的满二叉树中：**子节点/2=父节点**  
2-从左到右，从右到左的转换公式： **f(x)=(min+max) - sx**

# 3-Filling Bookcase Shelf
## KEY: 动态规划
这题先放着。  
这题贪心法弄不了，在一步中，怎么放要根据后面的状态来决定，这是得分叉。似乎就是有点DP的感觉了

# 4-Parsing A Boolean Expression
## KEY: 栈/公式递归
我的思路是，是每一步找到一个可化简项，循环到不可化简之后直接出答案。但是写法很差，可以参照stack，下面的写法1，思路其实是一样的。
## 写法1： 栈-Polish Notaion
波兰式表达法：operator（element1,element2,..）  
总是操作符在前，操作数在后，每次这样，往复递归即可。  
### **使用stack的定律**：
整个公式直接推进栈，直到第一次遇到')',说明有可简化的项，可以直接向前找操作符。

## 写法2： 递归，如何找子式
主要就是& 和 | 要子式子有点麻烦，需要对‘（’计数，如果遇见“，”的时候，发现"("数量为0，也就是说呗中和掉了，那么这就是分界线了
