# 1 - Occurrences After Bigram
## Key：  
简单题  
## Failures：
**【直接AC】**  
# 2 - Letter Tile Possibilities
## Key：  
情况分类树 
## Failures:
**【直接AC】**
# 3 - Insufficient Nodes in Root to Leaf Paths
## Key: 树递归

这就是一道比较直白的递归，递归遍历路径到叶子节点判断结果，然后回传父级，父级根据子节点的情况再判断
## 对递归以及树的遍历流不熟悉：  
我原本的写法，就是一次递归下去，把结果存在map上，然后再遍历一遍过来删节点。 之所以遍历2次，是我忘了递归还有回传再次处理的机会。    
（另外，map的key必须是可排序的，人家内部实现是红黑树啊！所以如果是struct，class之类的，要重载>才能用）

人家先递归调用，这里有一次信息传递的机会；然后就是一步步回传返回值，这里又有一次信息传递的机会，用于父级来处理。

# 4 - Smallest Subsequence of Distinct Characters
## Key:最优解，贪心
## **如何面对复杂逻辑？**
这道题我的解法逻辑很复杂，写这种短码一般很少用子函数，直接好几层for和分支，频繁出错，调了好久才对。
## map和set ， hash
我看了，R99的代码和我的思路是一模一样的，但我的runtime要高一截，这是为什么？？

# Lession
## 代码经验1
推荐BFS式的写法，即先写好框架和伪代码，再层层推进。  
因为如果采用DFS式的写法，即先把一部分写完，在比较紧张和混乱的情形下，是很容易遗漏的。如忘记返回值了，忘记break了。
## 代码经验2（time limit）
在解第二题的时候，虽然是直接AC的，但run的时候出现time limit，浪费了我十多分钟。这种不一定是算法缺陷，而是死循环的bug。  
所以首先检查下所有的for和while：  
1-判断调节有没有写错  
2-下标++之类的有没有漏写  
3-i，j，k之类的有没有搞混了
## 【第2题】情况分类树：通过推演解决排列组合问题
这道题很明显，是可以用排列组合直接推数学公式的。但是，在程序思维上，我们是可以**通过构建“分类树”，来对所有可能性进行枚举**。  
其好处是，代码和实现十分简单，同时正确性能够得到保障，如果推数学公式，很容易搞不好就犯错（尤其是这种排列组合，你懂的）
  
但是，记住要看一下题目给定的数值范围：  
**一定要估一下会不会超时or栈溢出！！**   
**一定要估一下会不会超时or栈溢出！！**  
**一定要估一下会不会超时or栈溢出！！** 

## 【第4题】思路分析
这是要在一堆次
## 技巧-every->极值判断
## STL：struct/pointer 作map的key