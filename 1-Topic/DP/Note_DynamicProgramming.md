# 1 - DP的实质
### **是一种优化策略：通过只计算一次重叠子问题，消去递归中冗余计算。**

## DAG 表述
几乎所有的DP情形都可以描述为一个有向图（DAG）：    

 - 每个节点都是代表一个状态，每条边链接了两个状态，同时又各自的cost。 寻找最优解的实质，不过寻找从初始节点到目标节点的最短路。    

 - 而动态规划的过程在于，要找到达某一点的最短路，只要分别求出其前驱的最短路，再取最优值即可。**因为这一点只有可能从前驱得来**。  
  - 所以DP为什么work？ 因为   
  1） 状态可转移，我们可以直接利用该状态的值，而不必要知道这个状态是怎么来的（是经过了哪些节点而来）  
  2）保证前驱最优：正确的计算顺序很重要   
  3）保证前驱完备：不要漏掉可能的前驱最优解。  
  这些条件一保证，那么结果就是妥妥的最优解了，不用担心漏情况之类的东西了。
## DP与贪心
其实贪心算法可以看做是DP的特殊情况，只不过每次贪心转移的时候，最优解是唯一的，指定的，而DP要一个个遍历过去取最优值。
# 2 - DP的关键点
## 2.1 - 什么时候用DP?
- 自然递归性质（前提性）  
问题的核心逻辑结构是**序列、集合、树、图、矩阵** 这样天生代递归性的。如果没有递归，那么子问题和母问题之间没法转移。  

- 搜索中存在冗余 （必要性）  
递归性质的逻辑结构在问题中很常见，但并不是所有都需要动态规划。   
有的题可以通过设计规则，或贪心之类的避免了暴力搜索。**只有当走投无路，走上搜索这条贼船，而且搜索中存在重复计算** 才需要考虑，能否使用动态规划。

## 2.2 - 状态
状态的定义十分艺术，不管怎么样，你定义的状态应该和是**能很好的表述子问题的最优解** ， 从而方便子问题的重复利用（即状态的转移）
 -  状态的维度   
 状态不一定是单维度的，很多重要的信息，以及限定条件，我们需要**作为状态的一个维度来进行跟踪**。

## 2.3 - 顺序
更新状态的顺序十分重要，一个原则就是：**在更新一个状态是，保证它的所有前驱已经更新完毕。**  
（当然，有的写法是按元素更新，而不是按状态更新，这里讨论的是按状态更新）
 

# 3 - 经典例题
## 3.1 - 背包-无序集合模型
## a.无限背包  
 - 状态定义：  
d（w）表示重量为w时的最优价值。 很直接，因为重量是这道题唯一的一个**限定条件**。  
 - 状态转移  
d（w1）到d（w2）之间的桥梁也很明确，就是添加了物体。因此，所有类型的重量就代表了完备的前驱的集合。 
 - 顺序：   
w小的是w大的前驱，因此知道从0到max算过去就可以保证前驱最优。 
## b.01背包
分析：相比于无限背包，01背包又多了个限定条件。面对限定条件我们怎么办？ 当然是让状态添加一个维度来跟踪。   
 - 集合状态：编号法
我们比无限背包多了一个维度d(w,s)，w还是w，s表示是只考虑前s个物体的情况。  
这个状态和w不太一样，实际上，对于无序的集合，我们可以对其元素进行编号，然后再一步步扩张。
 - 前驱的完备性
我们把注意力放在s这个维度上，从s到s+1，代表多考虑一个。因此只有两种情况，放或不放。
 - 二维状态的顺序：
这里的前驱后驱还是很明显的，w和s都是按数值大小的。两层for就可以保证。

## 3.2 -序列-序列模型
序列本身就是一种递归模型，往前或往后加一个元素，还是序列。  
### a.最大递增子序列
 - 状态的定义S（i）：  
  这道题说明了状态的定义，**未必要和规模挂钩，而是与关键位置挂钩**。S（i）如果表示，到第i个结尾的规模，那么状态之间的关联性就没了，不方便转移 。  
  这里元素的拼接，光知道规模无法推断，要比较当前递增序列的末尾元素的大小。所以，**如果i表示成规模，那么需要额外加维度来跟踪**。也就是S(i,j)表示到第i个规模，第j个元素为结尾的。  
  这里因为“规模”在状态转移基本没提供什么额外信息，因此i表示以第i个结尾的，不但暗示进程，还提供了信息。
### b.编辑距离
 - 状态的定义S（i，j）  
 这里是有两个序列，那么他的规模自然是要有两个维度，分别表示两个序列的规模。
 - 前驱的完备性  
 这里需要考虑的，就是DAG中，哪些状态有链接。少算一个都是漏解。这里S（i，j）只能被S（i，j+1）， S（i+1,j）和S（j+1，i）重复利用。**这其实就是二维的状态的一种i++**。

### c.矩阵乘法
 - 树结构  
 这题虽然看上去是序列模型，但其实加括号层级这件事，是一个树结构，也就是子结构是一颗子树。
 - 发现重复计算  
 这题如果去暴力枚举的话，你会发现有很多重复的结构。比如第2到第7个字母的某一个层级结构被枚举了很多次。而这就是活生生的重叠子问题。  
 - 状态的定义S（i，j）  
 和最大递增子序列不同的是，这里的规模，是两端截取的，而不是一段截取的。这主要是子问题的利用结构 和 扩展结构的不同，这个只可会意，不可言传hhh。

## 3.3 - 最短路-限制与多维度
 - **Dijstra 是动态规划吗？**  
 如果狭义地说，不能算是，因为他每次利用的中间结果，都不是最优子结构。而是一步步地更新。但是他有点那么动态规划的味道，即存储并利用中间结果。
### a.带限定的最短路
 - 保证决策指标的单一性  
 这题有个限定条件，穿过的节点不能过阈值。那么如何记录这个阈值呢。首先的想法是，子状态除了记录当前距离，还记录节点数。那么问题就来了，这个节点数是要参与决策的，我们算min的时候就没法算，因为2个指标我们不知道怎么取。这也就是动态规划的决策指标往往只有一个的原因。  
 - 状态升维的实质  
 我们没法断定节点数怎么取怎么办？ 那我就干脆把所有可能的候选者按节点数统统列出来，最后算完了再来挑。  
 这个在表面上是添加了一个维度，实质上是对这个变量进行枚举。
### b.全最短路径
严格的说，这题似乎不是动态规划，因为他的过程的递归性不是那么明显。但是他很DP的一点在于，他很巧妙的存储和利用了中间结果。  
 - 冗余计算在哪里？  
这题最暴力的计算，可以对每个节点都算一遍Dijkstra。但是比如D到E节点这条最短路径，其实在每次算Djkstra的时候都被利用过。也就是说，某点之间的最短路，可以被更远两点之间的最短路利用。
 - 编号法    
 这题的状态S（i，j，k）定义为点i到点j之间，考虑到k编号为止作为中间路径的，最短路。  
 为什么要定义这个k呢？这个k其实就很像规模扩张的一个状态，他保保证考虑过程中对每个元素的考虑是有序的，唯一的。因为k-1 一定是k的子集，是严格的子问题。  
 **对于无序的元素集合，编号扩张似乎是个比较靠谱的技巧** 其实01背包也是对物件进行了编号，这里图和背包的元素一样，由于没有明显的前后驱，我们可以认为进行ID编号，从而有了子问题更新顺序的问题。  
 编号之后，状态之间的前后驱十分明显，更新和计算的顺序也因此十分明显，因为这正是一个扩张规模的过程。

### c.销售员问题
 - 使用编号法需要注意的：   
 编号的过程，其实就是规定的节点的出现顺序，**即默认了是节点出现顺序无关的。**  
 而这里的元素并不是出现顺序无关的 ，因为我状态转移是要看最后一个节点是谁，然后拼接，因此如果一个阶段被编号到很后面，那么他必然出现在路径的后面。而最优解可能这个节点就是第一个。

 - 暴力版编号法：  
 其实编号法的目的，就是用“规模”来表示状态，从而规定推进的顺序。  
 那么我们完全可以**以集合S为状态** ， 它表示考虑集合里面的元素时的解。 我们更新的顺序，就是按S的元素个数。

 - 额外信息  
 判断转移条件需要知道额外信息（就像最大升序列一样），因此，我们进行升维。 于是状态改为D（S，i），这表示用了S，而且以i节点结尾。  
 
 - 还原最初的暴力感  
从暴力编号，到额外信息的升维，我们看到可一个复杂图越来越复杂的过程。 这也是DP种灵活的地方：**如果不确定，那么就枚举，就加状态，到确定为止!** 

 到此为止，计算顺序就十分明显，我们只要按S的大小遍历（每个S再遍历每个元素）即可  
 C（S，j）= min（C（S-j，i），dij） 
