# 1-Defanging an IP address
## KEY：简单题

# 2-Corporate Flight Booking
## KEY: hack
这题，就是大规模的执行+=会超时。  
但是注意一点，这里的累加的是同一个数字，因此有优化的方法：  
1-使用SIMD，long int来存储  
2-使用trick，比如从i加到j ，只需要a[i]+=n,a[j]-=n.  
待到所有都操作了一遍后，a[i]+=a[i]-1 轮一遍就应用了上去。

# 3-Delete Nodes And Return Foriest
## KEY: 树基础
树递归的时候，在大多数情况下，其实就是看某种操作发生或某种条件满足是，子级怎么对待父级，父级怎么对待子级。
### 传递前驱
这里需要传递前驱是必须的：  
1-子节点满足的时候，需要操作父节点进行脱离。  
2-通过前驱是否为null，来判断自己是否为forist的root

# 4-Maximum Nesting Depth of Two Valid Parentheses Strings
## KEY:括号栈
根据括号栈的定律（下面），我们只要把深度为基数和深度为偶数的分离开就行了。因为：    
```
0-抽出同深度的，依然是匹配的**（这条是核心）**    

1-若seq的深度为n，那么一定存在一个深度为n的子式子    

3-若把深度为n的式子，按照奇偶分离，加起来就是深度为原来的。（比如是1->2->3->4->5 分解为1->3->5 和 2->4 ）    
```
### 其他方法
比如1，2，3，4，5深度，我们也可以1，2，3 / 4,5 这么分。 但和奇偶一样的是，我们一定是把同深度的给抽出来

## 栈的定律
```
1-对"(" +1，对")" -1, 当前的score 就是深度（**单独算深度甚至不需要栈，计数一下就行**）    

2-每当push”）“，说明了当前深度的一个括号结束。 每当push”（“说明当前深度的一个括号开始    

3-如果一个括号的深度为n，那么它里面一定包含了深度为n-1, n-2,n-3....,1 的括号公式
```

## 一个判定奇偶的写法
```
if(a%2){
    //a为奇数
}
else{
    //a为偶数
}
```

## 奇偶分法
把一个数x分得最平均，就是一个为**x/2** 一个为**x-x/2**  
其中x/2的int截取效果，会根据x的奇偶自动适配